1. Що таке JavaScript та для чого він використовується?

2. Що таке Cypress та для чого він використовується?

3. Які основні принципи автоматизації тестування ви знаєте?
```
Тести повинні бути надійними та стабільними: автоматичні тести повинні бути написані таким чином, щоб давати правильні результати в більшості випадків, і не містити помилок, які можуть призвести до помилкових негативних або помилкових позитивних результатів.

Тести повинні бути підтримуваними та розширюваними: автоматичні тести повинні бути написані таким чином, щоб їх легко було підтримувати та модифікувати, коли програма змінюється.

Тести повинні бути повторюваними: автоматичні тести повинні давати однакові результати при кожному запуску, щоб можна було впевнено визначати, чи є зміна у додатку причиною відхилення результатів тесту.

Тести повинні бути прозорими: результати тестів повинні бути легко доступними для перегляду та розуміння для всієї команди розробки.

Тести повинні бути автоматичними: автоматичні тести повинні запускатися автоматично, коли вносяться зміни до додатку, і повинні завершуватись автоматично, коли тести виконані.

Тести повинні бути швидкими: автоматичні тести повинні виконуватися швидко, щоб розробники могли швидко отримати зворотний зв'язок про те, як зміни додатку впливають на роботу функцій.

Тести повинні бути засновані на реальних умовах використання: тести повинні імітувати реальні сценарії використання програми, щоб переконатися, що вона працює так, як має працювати у реальному середовищі.

Тести мають бути інтегровані у процес розробки: автоматичні тести мають бути інтегровані у процес розробки, щоб розробники могли швидко отримувати зворотний зв'язок у тому, як зміни у додатку впливають працювати функцій.
```

4. Як ви використовуєте git у своїй роботі?
5. Що таке методологія git flow?
``` 
Git Flow – це набір правил та процесів для ефективної організації роботи з Git-репозиторієм у команді розробки програмного забезпечення. 
Ця методологія ґрунтується на використанні двох основних гілок – master та develop, та додаткових гілок для імплементації нової функціональності, виправлень помилок, релізів тощо.

Основні принципи методології Git Flow включають:

1. Основні гілки - master та develop:
- Гілка Master містить стабільну, готову до випуску версію програмного забезпечення.
- Гілка develop є робочою гілкою, на якій розробники об'єднують свій код для створення наступної версії програмного забезпечення.

2. Додаткові гілки:
- feature – використовується для розробки нових функцій, які будуть додані до наступної версії.
- release – використовується для підготовки нової версії програмного забезпечення до випуску.
- hotfix – використовується для виправлення критичних помилок у поточній випущеній версії програмного забезпечення.

3. Суворий процес злиття та релізів:
- Усі зміни в коді мають відбуватися через окремі гілки.
- Релізи мають бути ретельно тестовані та готові до випуску.

4. Автоматизація та безперервна інтеграція:
- Необхідно використовувати інструменти для автоматизації процесів, такі як пайплайни CI/CD, автоматичні тести і т.д.

Методологія Git Flow дозволяє розробникам ефективно працювати в команді, керувати версіями програмного забезпечення та випускати нові версії з мінімальною кількістю помилок та проблем.
```
6. Які принципи лежать в основі Continuous Integration та Continuous Deployment?

```
Continuous Integration (CI) та Continuous Deployment (CD) - це два пов'язані процеси, які допомагають автоматизувати процес складання (app build), тестування та розгортання додатків. Ось деякі принципи, які лежать у їх основі:

Автоматизація: у CI/CD процесі всі етапи, від складання та тестування до розгортання програми, мають бути повністю автоматизовані. Це дозволяє швидко виявляти та виправляти помилки, а також гарантує, що кожна нова версія програми буде розгорнута в однаковому середовищі.

Часті релізи: в CI/CD процесі команда випускає нові версії програми часто і регулярно, замість того щоб чекати кілька місяців перед випуском нової версії. Це дозволяє швидко реагувати на зміни ринку та зворотний зв'язок від користувачів.

Моніторинг та логування: у CI/CD процесі всі етапи повинні бути ретельно моніторитись та логуватись, щоб можна було швидко виявляти та виправляти проблеми.

Тестування: в процесі CI/CD тестування відіграє центральну роль. Команда повинна писати автоматичні тести для кожної нової функції, а також інтеграційні тести для перевірки роботи системи в цілому.

Контроль версій: у CI/CD процесі використовується система контролю версій для зберігання та керування кодом. Це дозволяє команді швидко повернутися до попередньої версії програми у разі проблем.

Консистентність оточення: в CI/CD процесі необхідно гарантувати, що оточення для тестування та розробки програми ідентично оточенню, що використовується в продакшені. Це дозволяє виявляти проблеми, які можуть виникнути при переході з одного середовища до іншого.

Всі ці принципи допомагають прискорити процес розробки, підвищити якість програми та забезпечити надійність та передбачуваність у роботі команди.
```
7. Які типи тестів ви знаєте?
8. Що таке юніт-тести?
9. Що таке інтеграційні тести?
10. Що таке функціональні тести?
11. Що таке тести E2E?
12. Що таке селектори в Cypress?
13. Які функції керування часом у Cypress ви знаєте?

```
cy.wait() - функція, що дозволяє затримати виконання тесту на певний проміжок часу. Це може бути корисним, наприклад, якщо ви хочете дочекатися завершення анімації або завантаження сторінки.

cy.tick() - функція, яка дозволяє емулювати минулий час. Це може бути корисним, наприклад, якщо ви хочете перевірити, що таймери або інтервали працюють правильно.

cy.clock() - функція, яка дозволяє керувати внутрішнім годинником Cypress. Це може бути корисним, наприклад, якщо ви хочете емулювати довгий процес або перевірити, чи функція setTimeout() викликається з правильним інтервалом.

cy.waitUntil() - функція, що дозволяє дочекатися виконання певної умови. Це може бути корисним, наприклад, якщо ви хочете дочекатися завершення асинхронної операції або появи елемента на сторінці.

cy.timeout() - функція, яка дозволяє встановити максимальний час очікування команди. Це може бути корисним, наприклад, якщо ви хочете запобігти зависанню тесту на кілька хвилин через тривале завантаження сторінки.

Ці функції допомагають керувати часом у тестах і забезпечують більш надійну та передбачувану поведінку ваших тестів.
```

14. Що таке фікстури в Cypress?

```
Фікстури в Cypress - це файли даних, які використовуються для надання початкових даних або стану під час тестування програми. Вони можуть містити різні типи даних, наприклад JSON, XML, CSV та інші.

Фікстури можуть бути використані у тестах за допомогою методу cy.fixture(). Цей метод завантажує фікстуру на її ім'я та повертає її вміст у вигляді об'єкта JavaScript. Або також просто імпортовані напряму в файл.

Приклад використання фікстур у Cypress:

// fixtures/data.json
{
  "username": "testuser",
  "password": "secretpassword"
}

// test.js
describe('My test', () => {
  beforeEach(() => {
    cy.fixture('data.json').as('userData')
  })

  it('Logs in with the correct credentials', function() {
    cy.visit('/login')
    cy.get('#username').type(this.userData.username)
    cy.get('#password').type(this.userData.password)
    cy.get('#login-button').click()
    cy.url().should('include', '/dashboard')
  })
})

У цьому прикладі ми визначили фікстуру у файлі data.json, що містить дані для логіну в додаток. Потім ми завантажуємо фікстуру за допомогою методу cy.fixture() в beforeEach() блоці та зберігаємо її під псевдонімом userData. У тесті ми використовуємо дані з фікстури для заповнення полів логіну та перевіряємо, що користувач успішно увійшов до системи.

Використання фікстур у Cypress допомагає скоротити дублювання коду та спростити підтримку тестових даних.
```

15. Який метод краще використовувати для відкриття нової сторінки в Cypress?

```
У Cypress найкраще використовувати метод cy.visit() для відкриття нової сторінки, оскільки він має вбудовану обробку помилок і гарантує, що сторінку буде повністю завантажено перед продовженням тесту.

Метод cy.visit() дозволяє завантажувати сторінки за URL-адресою або відносною дорогою, а також встановлювати опції, такі як тайм завантаження сторінки і примусове перезавантаження сторінки.

Приклад використання методу cy.visit() для відкриття нової сторінки:

describe('My test', () => {
  it('Opens a new page', () => {
    cy.visit('https://www.example.com')
    cy.get('a').contains('New Page').click()
    cy.url().should('include', '/newpage')
  })
})

У цьому прикладі ми відкриваємо сторінку https://www.example.com, потім знаходимо посилання з текстом New Page і клацаємо на неї. Після цього ми перевіряємо, що URL-адреса містить фрагмент "/newpage".

Метод cy.visit() автоматично очікує на завантаження сторінки і гарантує, що сторінка буде повністю завантажена перед продовженням тесту. Це допомагає уникнути проблем із тайм-аутами або помилками завантаження сторінки, які можуть виникати при використанні інших методів для відкриття нової сторінки в Cypress.

---------
Cypress має кілька методів для відкриття нової сторінки, крім cy.visit(). Розглянемо деякі з них:

1. cy.request(): цей метод використовується для надсилання HTTP-запитів. Він може бути використаний для відправки GET-запиту на певну URL-адресу, яка в свою чергу може повернути HTML-сторінку. Однак при використанні цього методу не буде виконано повне завантаження сторінки, оскільки він не запускає браузер.

describe('My test', () => {
  it('Opens a new page', () => {
    cy.request('https://www.example.com/newpage')
    cy.url().should('include', '/newpage')
  })
})

2. cy.window(): цей метод використовується для отримання об'єкта window поточної сторінки, на якій виконується тестування. Він може бути використаний для відкриття нової вкладки або вікна, але цей процес буде більш складним, ніж при використанні cy.visit().

describe('My test', () => {
  it('Opens a new page', () => {
    cy.window().then((win) => {
      win.open('https://www.example.com/newpage')
    })
    cy.url().should('include', '/newpage')
  })
})

3. cy.get(): цей метод використовується для пошуку елемента на поточній сторінці та подальшого виконання дій з ним. Він може бути використаний для натискання посилання або кнопку, які призведуть до відкриття нової сторінки.

describe('My test', () => {
  it('Opens a new page', () => {
    cy.visit('https://www.example.com')
    cy.get('a').contains('New Page').click()
    cy.url().should('include', '/newpage')
  })
})

В цілому, cy.visit() є найкращим методом для відкриття нової сторінки в Cypress, оскільки він дозволяє гарантувати, що сторінка повністю завантажена перед продовженням тесту.
```

16. Що таке хуки в Cypress?

```
Хуки (hooks) у Cypress - це функції, які виконуються перед або після виконання тестів. 
Вони використовуються для налаштування тестового оточення, виконання дій до або після кожного тесту, підготовки даних та очищення стану програми.
```

17. Які хуки в Cypress ви знаєте?

```
Cypress підтримує кілька типів хуків:

1. before та beforeEach: ці хуки виконуються до запуску всіх тестів або перед кожним тестом відповідно. Вони можуть використовуватися для наоаштування оточення перед запуском тестів, наприклад, для запуску сервера, завантаження даних або входу до програми.

before(() => {
   // Виконується перед запуском всіх тестів
})

beforeEach(() => {
   // виконується перед кожним тестом
})

2. after та afterEach: ці хуки виконуються після виконання всіх тестів або після кожного тесту відповідно. Вони можуть використовуватися для очищення стану програми після завершення тестів.

after(() => {
   // виконується після виконання всіх тестів
})

afterEach(() => {
   // виконується після кожного тесту
})

3. beforeAll і afterAll: ці хуки виконуються один раз до або після виконання всіх тестів відповідно. Вони можуть використовуватися для виконання тривалих операцій, наприклад створення бази даних або підготовки даних.

beforeAll(() => {
   // Виконується один раз перед запуском всіх тестів
})

afterAll(() => {
   // Виконується один раз після виконання всіх тестів
})

Хуки можуть бути визначені як в окремому файлі тесту, так і в загальному файлі, який підключається до всіх тестових файлів. Використання хуків дозволяє значно спростити налаштування та підтримку тестових сценаріїв у Cypress.
```

18. Які є звіти про виконання тестів у Cypress? Як їх налаштувати?

```
Cypress надає кілька способів настроювання звітів про виконання тестів. Розглянемо найпопулярніші:

1. Cypress Dashboard
Cypress Dashboard - це хмарний сервіс, який дозволяє зберігати та переглядати звіти про виконання тестів. Для використання сервісу необхідно зареєструватися на сайті, отримати API-ключ та налаштувати інтеграцію з проектом Cypress.

Після налаштування інтеграції результати виконання тестів автоматично відправлятимуться в Cypress Dashboard, де їх можна переглянути у зручному вигляді, а також отримувати повідомлення про проходження тестів на пошту або Slack.

2. Mochawesome
Mochawesome - це модуль для створення звітів у форматі HTML. Він може використовуватися для створення звітів про виконання тестів у Cypress.

Для встановлення Mochawesome необхідно виконати такі команди у терміналі:

npm install --save-dev mochawesome

Після встановлення модуля необхідно налаштувати Cypress для використання Mochawesome як репортера:

// у файлі cypress.json
{
  "reporter": "mochawesome",
  "reporterOptions": {
    "reportDir": "cypress/reports/mochawesome",
    "overwrite": false,
    "html": false,
    "json": true
  }
}

Потім можна запустити тести та згенерувати звіт командою:
npx cypress run --reporter mochawesome

Після виконання команди в папці cypress/reports/mochawesome буде створено звіт у форматі JSON, який можна перетворити на HTML-файл за допомогою утиліти marge.

3. Cucumber
Cucumber – це інструмент для написання тестів на основі BDD. Він може використовуватися в Cypress для створення звітів про виконання тестів у форматі HTML.

Для використання Cucumber необхідно встановити відповідні модулі:

npm install --save-dev cypress-cucumber-preprocessor cucumber

Потім необхідно налаштувати Cypress для використання Cucumber як репортер:

// у файлі cypress/plugins/index.js
const cucumber = require('cypress-cucumber-preprocessor').default

module.exports = (on, config) => {
  on('file:preprocessor', cucumber())
}

Після цього можна писати тести у форматі Gherkin та запускати їх за допомогою команди:

npx cypress run --spec "cypress/integration/**/*.{feature,features}"

Після виконання команди у папці cypress/reports/cucumber буде створено звіт у форматі HTML.

Це лише декілька з багатьох способів.
```

19. Що таке beforeEach і afterEach хуки в Cypress?

```
1. beforeEach: ці хуки виконуються перед кожним тестом . Вони можуть використовуватися для наоаштування оточення перед запуском тестів, наприклад, для запуску сервера, завантаження даних або входу до програми.

beforeEach(() => {
   // виконується перед кожним тестом
})

2. afterEach: ці хуки виконуються після кожного тесту відповідно. Вони можуть використовуватися для очищення стану програми після завершення тестів.

afterEach(() => {
   // виконується після кожного тесту
})
```

20. Що таке context у Cypress?

```
У Cypress, контекст (context) - це об'єкт, який використовується для збереження та передачі даних між різними тестами та функціями у вашому коді тестів.

Контекст у Cypress має глобальну область видимості, що означає, що будь-яка функція у коді тестів може отримати доступ до даних у контексті, не маючи доступу до змінних в інших функціях або тестах.

Ви можете додавати дані в контекст за допомогою методу cy.wrap(), який обгортає значення в об'єкт Cypress і додає його в контекст:

cy.wrap({foo: 'bar'}).as('myData');

Тут ми обернули об'єкт {foo: 'bar'} в об'єкт Cypress, а потім додали його в контекст під назвою myData.

Щоб отримати доступ до цих даних в іншому тесті або функції, можна використовувати метод cy.get() і передати ім'я, яке ви використовували при додаванні даних в контекст:

cy.get('@myData').then((data) => {
// Do something with the data
});

Тут ми отримали доступ до даних, які додали в контекст раніше, використовуючи ім'я myData.

Контекст у Cypress може використовуватися для передачі даних між тестами, зберігання стану програми, створення сценаріїв тестування та багато іншого. Він є потужним інструментом для створення ефективних і гнучких тестів в Cypress.
```
21. Що таке Alias у Cypress?

```
Alias у Cypress - це механізм для створення та використання псевдонімів для вибраних елементів DOM, ланцюжків команд та результатів запитів. Alias дозволяє зберегти вибрані елементи та команди у змінних, щоб можна було повторно використовувати їх в інших місцях вашого коду тестів.

Наприклад, якщо ви хочете зберегти результат вибірки елементів у змінній, ви можете використовувати метод as() для створення псевдоніму:
cy.get('button').as('myButton');

Тут ми вибрали всі кнопки на сторінці та дали їм псевдонім myButton. Тепер ми можемо використовувати цей псевдонім в інших місцях нашого коду:
cy.get('@myButton').click();

Тут ми використовуємо псевдонім myButton для отримання всіх елементів кнопки, вибраних раніше, і виконуємо для них кліку.

Alias також може бути використаний для збереження результатів ланцюжків команд, таких як contains() або within(). Наприклад:
cy.get('form')
  .within(() => {
    cy.contains('Submit').click();
  })
  .as('submitForm');

Тут ми використовуємо метод within() для вибору елемента форми, а потім виконуємо команду кліка для кнопки з написом "Submit". Результат ланцюжка команд зберігається за допомогою методу as() у псевдонім submitForm, який ми можемо використовувати в інших частинах нашого коду.

Використання Alias у Cypress дозволяє створювати більш гнучкі та підтримувані тести, спрощуючи повторне використання вибраних елементів та команд.
```

22. Як використовувати бібліотеку Chai у Cypress?
``` 
Бібліотека Chai у Cypress дає можливість використовувати кілька різних синтаксисів для написання перевірок, включаючи .should(), expect() та assert().

Синтаксис .should() використовується для ланцюжків команд і дозволяє послідовно перевіряти властивості елементів. 
Наприклад:

cy.get('button')
   .should('be.visible')
   .should('have.class', 'primary')
   .click();

Синтаксис expect() використовується для написання складніших перевірок, які не можуть бути виражені за допомогою .should(). 
Наприклад:

cy.get('input[name="username"]')
   .then( $input => {
     expect($input).to.have.attr('placeholder', 'Enter your username');
     expect($input).to.have.css('background-color', 'rgb(255, 255, 255)');
   });

Синтаксис assert() використовується для написання перевірок за допомогою бібліотеки Chai, яка надає ширший набір тверджень. 
Наприклад:

cy.get('#myElement')
  .invoke('text')
  .then( text => {
    assert.include(text, 'expected text')
  })

```
23. Які найпоширеніші проблеми у тестуванні ви можете зустріти?

```
Деякі з найбільш поширених проблем, з якими можна зіткнутися в тестуванні, включають:

Недостатнє покриття тестами: це може призвести до того, що багато помилок залишаться непоміченими, особливо у випадках, коли тестується складний функціонал.

Нестабільність тестів: тести, які іноді проходять, а іноді ні, можуть сильно уповільнити процес тестування, і в результаті змусити команду тестування витрачати багато часу на їх налагодження.

Неправильне використання очікувань: неправильне використання очікувань може призвести до того, що тести будуть давати помилкові спрацьовування, коли тестований функціонал працює коректно.

Проблеми з тестовими даними: некоректно підготовлені або неправильні тестові дані можуть призвести до неправильних результатів тестування.

Проблеми з оточенням тестування: необхідно переконатися, що оточення, на якому тестується програма, коректно налаштоване, і що тести виконуються у стабільному оточенні.

Недостатня взаємодія з розробниками: недостатня взаємодія та відсутність спільної роботи з розробниками може призвести до проблем у процесі тестування, таких як відсутність необхідної інформації про функціонал або про те, як правильно його протестувати.

Необхідність підтримки тестів: необхідно переконатися, що тести підтримуються в актуальному стані та виконуються регулярно, щоб забезпечити їхню актуальність та ефективність у процесі тестування.
```
24. Що таке Page Object Pattern?

```
Page Object Pattern – це популярний патерн проектування, який використовується для тестування веб-додатків. Його мета полягає в розділенні коду тестового сценарію від коду, що відповідає за елементи інтерфейсу користувача (UI).

Суть Page Object Pattern полягає в тому, що кожна сторінка або компонент веб-застосунку представляється у вигляді об'єкта (page object), який інкапсулює всю логіку взаємодії з цією сторінкою або компонентом. Це означає, що всі дії та перевірки, пов'язані з цією сторінкою, можуть бути описані у цьому об'єкті.

Page Object Pattern має кілька переваг, включаючи:

Спрощення тестування: Page Object Pattern дозволяє легше писати тести, оскільки логіка взаємодії з кожною сторінкою вже інкапсульована в об'єкті, що робить написання коду тестів швидшим та зрозумілішим.

Змінність: зміни на сторінках веб-програми можуть бути легко керовані, оскільки зміни в одному об'єкті не вплинуть на інші об'єкти.

Повторне використання: Page Object Pattern дозволяє повторно використовувати об'єкти на інших сторінках або компонентах, що дозволяє уникнути дублювання коду та прискорити процес розробки тестів.

Читання: Пошук елементів на сторінці та виконання дій з ними – це одне з найчастіших завдань у тестуванні. Описуючи всі дії в об'єкті, Page Object Pattern таким чином дозволяє зробити код тестів більш читабельним та зрозумілим.

```


25. Які переваги та недоліки у шаблону проектування Page Object?

```
Переваги використання Page Object Pattern:

- Зменшення дублювання коду. Код тестів може стати більш зрозумілим і підтримуваним завдяки відділенню коду тестів від коду елементів інтерфейсу користувача.

- Спрощення обслуговування. Якщо програма змінюється, розробник може оновити код у Page Object, який відповідає за елементи інтерфейсу користувача, і всі тести, які використовують цей об'єкт, будуть оновлені автоматично.

- Збільшення продуктивності. Page Object може використовуватися в декількох тестах, що дозволяє уникнути повторної ініціалізації одних і тих же елементів інтерфейсу користувача в різних тестах.


Недоліки використання Page Object Pattern:

- Необхідність підтримувати код Page Object. Оскільки Page Object використовується для абстрагування елементів інтерфейсу користувача, необхідно підтримувати його в актуальному стані.

- Необхідність ретельно продумати архітектуру Page Object. Добре спроектований Page Object може значно покращити структуру та спростити тести, але якщо його неправильно спроектувати, це може призвести до додаткової складності та витрат на підтримку коду.

- Деякі завдання можуть бути складнішими для реалізації за допомогою Page Object. Наприклад, тестування елементів інтерфейсу користувача, які генеруються динамічно, може виявитися складним при використанні Page Object.
```
26. Яка різниця між xpath та css селекторами?
``` 
XPath і CSS селектори - це два основних методи пошуку елементів на веб-сторінці в Cypress.

CSS селектори швидше та простіше у використанні, ніж XPath, і їх легше підтримувати, якщо структура веб-сторінки змінюється. 
Однак CSS селектори можуть мати обмеження при пошуку елементів, які не мають унікальних класів або ідентифікаторів.

XPath використовується для пошуку елементів на основі їхньої позиції в структурі документа і може використовувати різні атрибути елементів. 
XPath не є нативним способом локалізації елементів у Cypress і для його використання необхідно встановити плагін.
Теоретично він може бути більш потужним, ніж селектори CSS, особливо при пошуку елементів, які не мають унікальних класів або ідентифікаторів. 
Однак XPath є повільнішим і більш складним у використанні, особливо для нових користувачів.

Загалом використання XPath або CSS селекторів залежить від конкретної ситуації, як правило, використання CSS в поєднанні з командами Cypress є вичерпним.
```
27. Який найкращий спосіб перевірити, що елемент є на сторінці?

``` 
Для перевірки наявності елемента на сторінці Cypress можна використовувати методи .should('exist') або .should('be.visible').

Метод .should('exist') перевіряє, що елемент присутній у DOM, незалежно від того, чи бачимо його на сторінці чи ні. 
Наприклад, якщо у вас є елемент із селектором .my-element, ви можете використовувати наступний код:

cy.get('.my-element').should('exist');

Метод .should('be.visible') перевіряє, що елемент присутній у DOM і бачимо на сторінці, тобто не прихований за допомогою CSS властивості display: none, visibility: hidden, або opacity: 0. 
Якщо елемент не відображається на сторінці, то тест не пройде і ви отримаєте помилку. 
Наприклад:

cy.get('.my-element').should('be.visible');

Обидва методи можуть бути використані для перевірки наявності елемента на сторінці, але вибір конкретного методу залежить від вашого конкретного завдання та сценарію тестування. 
Якщо вам важливо переконатися, що елемент бачимо на сторінці, використовуйте .should('be.visible'). 
Якщо потрібно лише перевірити, що елемент існує в DOM, але може бути прихований, використовуйте .should('exist').
```

28. Який найкращий спосіб перевірити, чи елемент прихований на сторінці?
```
Існує кілька способів перевірки, чи прихований елемент на сторінці Cypress, але найбільш надійний спосіб - це використання методу .should('not.be.visible').

Наприклад, якщо у вас є елемент із селектором .my-element і ви хочете переконатися, що він прихований, ви можете використовувати наступний код:

cy.get('.my-element').should('not.be.visible');

Метод .should('not.be.visible') перевіряє, що елемент не видимий на сторінці, тобто прихований за допомогою CSS властивості display: none, visibility: hidden, або opacity: 0. 
Якщо елемент відображається на сторінці, то тест не пройде і ви отримаєте помилку.

Інші методи, які можуть використовуватися для перевірки, чи прихований елемент на сторінці, включають:

.should('not.exist') - перевіряє, що елемент немає у DOM.
.should('have.css', 'visibility', 'hidden') - перевіряє, що елемент прихований за допомогою CSS властивості visibility: hidden.
.should('have.css', 'opacity', '0') - перевіряє, що елемент прихований за допомогою CSS властивості opacity: 0.

Однак ці методи можуть бути менш надійними, оскільки елемент може бути прихований іншими способами, які не перевіряються цими методами. 
Тому рекомендується використовувати .should('not.be.visible') для перевірки, чи елемент прихований на сторінці.
```
29. Який процес рефакторингу коду в тестах?
``` 
Рефакторинг коду в тестах - це процес зміни коду, який не змінює функціональності тестів, але покращує його якість, читання та підтримуваність. 
Процес рефакторингу не має строгих та стандартизованих підходів і є індивідуальним для кожного.
Як приклад, рефакторингу може включати такі кроки:

1. Оцінка поточного коду: перед початком рефакторингу необхідно оцінити поточний код, щоб зрозуміти, які зміни потрібні.

2. Дублікація тестових сценаріїв: для того, щоб зміни не вплинули на роботу тестів, необхідно продублювати або створити нові тест кейси (своєрідний бекап), які будуть використовуватися під час рефакторингу.

3. Зміна коду: на цьому етапі можна змінити код, включаючи перейменування змінних, видалення дублікатів, покращення логіки і т.д.

4. Перевірка коду: після внесення змін необхідно протестувати код, щоб переконатися, що він працює так, як задумано.

5. Фіксація змін: після успішного тестування змін слід зафіксувати їх у системі контролю версій.

Важливо пам'ятати, що рефакторинг коду в тестах не повинен змінювати функціональність тестів. 
Мета рефакторингу - поліпшити якість коду, зробити його більш читаним і підтримуваним, що допоможе уникнути проблем у майбутньому і прискорить розробку нових тестів.
```
30. Як обробляти асинхронні операції у Cypress?
```
У Cypress асинхронні операції можуть бути оброблені за допомогою команд then(), should(), invoke(), wait(), as() та wrap(), які забезпечують синхронне виконання наступних команд після завершення попередньої асинхронної операції.

Наприклад, щоб перевірити значення елемента, яке було встановлено асинхронно, ми можемо використовувати метод should(), який очікує на виконання асинхронної операції і потім перевіряє значення елемента:

cy.get('#my-element').should('have.value', 'expected value');

Якщо ми хочемо виконати послідовність команд після завершення асинхронної операції, ми можемо використати метод then(). 
Наприклад, якщо ми хочемо встановити значення елемента, а потім перевірити його значення, ми можемо написати наступний код:

cy.get('#my-element')
   .type('new value')
   .then(() => {
     cy.get('#my-element').should('have.value', 'new value');
   });
   
Також можна використовувати команду wait(), щоб дочекатися виконання асинхронної операції, наприклад, щоб дочекатися завантаження сторінки:

cy.visit('https://example.com')
   .wait(2000) // Дочекатися 2 секунди
   .get('#my-element')
   .should('have.value', 'expected value');
   
Использование методов as() и wrap() позволяет сохранять результаты асинхронных операций для дальнейшего использования в последующих командах.
```
31. Що таке асинхронний код JavaScript?
```
Асинхронний код JavaScript це код, який виконується не синхронно, тобто не по порядку. 
На відміну від синхронного коду, який блокує виконання подальших команд до завершення поточної операції, асинхронний код дозволяє продовжувати виконання інших операцій, доки операція виконується у фоновому режимі.

Асинхронний код зазвичай використовується для виконання завдань, які потребують часу, наприклад завантаження даних з мережі або читання файлів. 
JavaScript асинхронний код може бути написаний з використанням колбеків, промісів або асинхронних функцій. 
Ці механізми дозволяють написати код, який виконується асинхронно, але при цьому не блокує виконання подальших операцій і не призводить до зависання програми.
```
32. Які функції є у JavaScript для очікування асинхронних операцій?
```
Для очікування асинхронних операцій у JavaScript часто використовують такі функції керування часом:

setTimeout() - дозволяє викликати функцію після певної затримки у мілісекундах.

setInterval() - Викликає функцію через певний проміжок часу, заданий в мілісекундах.

Promise - є асинхронною операцією, яка може мати результат або помилку.

async/await – дозволяє писати асинхронний код, використовуючи синтаксис, схожий на синхронний, роблячи його більш зрозумілим та зручним для читання.

У Cypress, крім того, є спеціальні методи управління часом очікування, такі як .wait() і .should(), які дозволяють тесту чекати появи елементів на сторінці, зміни їх властивостей тощо.
```
33. Що таке Promise JavaScript?
```
Обіцянки (Promise) - це об'єкти в JavaScript, які є результатом асинхронної операції. 
Вони дозволяють виконати асинхронний код, а потім обробити результат у вигляді колбека.

Обіцянка може бути в одному з трьох станів: очікування (pending), виконане (fulfilled) або відхилено (rejected). 
Коли обіцянка перебуває в стані очікування, вона може перейти в будь-який із двох інших станів, залежно від результату асинхронної операції. 
Якщо операція завершується успішно, обіцянка переходить у стан 'виконано', в іншому випадку у стан 'відхилено'.

Обіцянки дозволяють зробити код більш читабельним і керованим, так як за допомогою ланцюжків обіцянок можна легко обробляти помилки та послідовно виконувати кілька асинхронних операцій.
```
34. Що таке then і catch методи JavaScript?
```
У JavaScript, метод then використовується для обробки успішного виконання обіцянки, тоді як метод catch використовується для обробки помилок, що виникають при виконанні обіцянки.

then приймає один чи два аргументи. 
Перший аргумент – функція callback, яка буде виконана при успішному виконанні обіцянки, і вона приймає як аргумент результат виконання обіцянки. 
Другий аргумент (необов'язковий) — функція callback, яка буде виконана, якщо відбудеться помилка під час виконання обіцянки.

catch приймає один аргумент - функцію зворотного виклику, яка буде виконана у разі помилки під час виконання обіцянки.

Зазвичай then і catch поєднуються для обробки обіцянок. 
Наприклад:

somePromiseFunction()
   .then(result => {
     // Обробка успішного виконання обіцянки
     console.log(result);
   })
   .catch(error => {
     // Обробка помилок під час виконання обіцянки
     console.error(error);
   });
У цьому прикладі then викликається при успішному виконанні somePromiseFunction(), а catch викликається у разі виникнення помилок.
```
35. Як використовувати async та await у JavaScript?
```
Асинхронні функції JavaScript можуть використовувати ключові слова async і await для управління асинхронною поведінкою.

Ключове слово Async використовується для визначення асинхронної функції, яка повертає обіцянку. 
Всередині такої функції можна використовувати await для очікування завершення асинхронних операцій замість використання колбеків або ланцюжка обіцянок.

Приклад використання async та await:

async function myAsyncFunction() {
   try {
     const result1 = await myPromiseFunction1();
     const result2 = await myPromiseFunction2(result1);
     return result2;
   } catch (error) {
     console.error(error);
   }
}

У цьому прикладі ми визначаємо функцію myAsyncFunction() як асинхронну за допомогою ключового слова async. 
Потім ми використовуємо await для очікування на результату двох асинхронних функцій myPromiseFunction1() і myPromiseFunction2(), які повинні повертати обіцянку. 
Ми також використовуємо блок try-catch для обробки помилок.

Коли викликається функція myAsyncFunction(), вона виконуватиметься асинхронно та повертатиме обіцянку, яку можна дозволити за допомогою методу then() або обробити за допомогою методу catch().
myAsyncFunction()
   .then(result => {
     console.log(result);
   })
   .catch(error => {
     console.error(error);
   });

У цьому прикладі ми викликаємо функцію myAsyncFunction() та обробляємо її результати за допомогою методів then() та catch(). Якщо функція завершується успішно, ми виводимо її результат у консоль. Якщо відбувається помилка, ми виводимо повідомлення про помилку в консоль.
```
36. Як керувати різними оточеннями та налаштуваннями конфігурації в Cypress?
```
У Cypress є декілька способів керувати різними оточеннями та налаштуваннями конфігурації. 
Один із найпоширеніших підходів - використання файлів конфігурації.

У корені проекту можна створити декілька конфігураційних файлів, наприклад:

cypress.json - основний конфігураційний файл, який буде використовуватися за замовчуванням.
cypress.dev.json – конфігураційний файл для оточення розробки.
cypress.staging.json – конфігураційний файл для середовища стейджингу.
cypress.prod.json – конфігураційний файл для продуктового середовища.
У цих конфігураційних файлах можна налаштувати різні параметри, такі як базовий URL, налаштування браузера, налаштування звітів і багато іншого.

Крім того, у Cypress є можливість передачі параметрів через змінні оточення. 
Наприклад, можна використовувати змінні оточення для налаштування авторизації або базової URL-адреси залежно від середовища виконання.

Для передачі змінних оточення можна використовувати командний рядок під час запуску тестів:
CYPRESS_BASE_URL=http://example.com cypress run

У тестах можна отримати значення змінних оточення за допомогою методу Cypress.env():

в теміналі:
export CYPRESS_BASE_URL=http://example.com

в тестах:
const baseUrl = Cypress.env('CYPRESS_BASE_URL');

Також у Cypress є можливість використовувати cy.task() для передачі параметрів з командного рядка до тестів:

cy.task('getConfig', { environment: Cypress.env('NODE_ENV') }).then((config) => {
   // Використання налаштувань
});


В цілому, варіанти керування різними оточеннями та налаштуваннями конфігурації в Cypress досить гнучкі та можуть бути налаштовані під конкретні потреби проекту.
```
37. Що таке успадкування JavaScript і як воно працює?
```
Успадкування JavaScript - це механізм, який дозволяє об'єктам успадковувати властивості та методи інших об'єктів. 
У JavaScript успадкування реалізується через прототипи об'єктів. 
Кожен об'єкт JavaScript має властивість prototype, яке є посиланням на об'єкт-прототип. 
Коли властивість об'єкта не може бути знайдена в самому об'єкті, JavaScript автоматично шукає його в об'єкті-прототипі, і так далі, доки не досягне кінця ланцюжка прототипів.

Наприклад, якщо ми маємо об'єкт Person, який містить властивості та методи, такі як name, age, speak(), то ми можемо створити інший об'єкт Employee, який успадковує властивості та методи об'єкта Person. 
Ми можемо зробити це, створивши об'єкт Employee за допомогою Object.create(), вказавши об'єкт Person як його прототип:

let Person = {
  name: '',
  age: '',
  speak: function() {
    console.log('Hello!');
  }
};

let Employee = Object.create(Person);

Employee.title = '';
Employee.salary = '';

Тепер об'єкт Employee має доступ до властивостей та методів об'єкта Person. 
Наприклад, ми можемо використовувати метод speak() об'єкта Person:

Employee.speak(); // виведе 'Hello!'

При цьому, якщо ми спробуємо звернутися до властивості або методу, якого немає в об'єкті Employee, JavaScript автоматично знайде його в об'єкті-прототипі Person.
```
38. Як використовувати ESLint у своєму проекті?
```
ESLint - це інструмент для статичного аналізу коду JavaScript, який допомагає виявляти потенційні проблеми та стилістичні помилки в коді. ESLint може бути використаний у проекті для забезпечення узгодженості коду та його якості.

Щоб використовувати ESLint у своєму проекті, необхідно виконати такі кроки:

Встановити ESLint у проекті за допомогою npm або yarn:

npm install eslint --save-dev
або
yarn add eslint --dev

Створити файл конфігурації для ESLint. Це можна зробити, запустивши команду:

eslint --init

Потім вам буде запропоновано вибрати кілька параметрів конфігурації, таких як тип використання (наприклад, браузер або Node.js), стиль кодування (наприклад, стандарт Airbnb), та додаткові параметри, такі як використання prettier.

Додати скрипт до package.json для запуску ESLint:

"scripts": {
   "lint": "eslint."
}

Запустіть ESLint, виконавши команду:
npm run lint

ESLint видасть звіт про всі знайдені проблеми у вашому коді. Якщо ви хочете, щоб ESLint автоматично виправляв знайдені проблеми, ви можете використати прапорець --fix:


npm run lint -- --fix

Загалом використання ESLint може значно покращити якість та узгодженість вашого коду, допомагаючи виявляти потенційні проблеми та помилки на ранній стадії розробки.
```
39. Які функції керування файлами ви знаєте в JavaScript?
```
JavaScript має кілька функцій для керування файлами:

fs - це вбудований модуль Node.js, який надає можливості для роботи з файловою системою комп'ютера. 
Він дозволяє виконувати такі операції, як читання та запис файлів, створення та видалення файлів та директорій, переміщення файлів та директорій та інші операції, пов'язані з файловою системою.
fs – це скорочення від "File System".

- fs.readFile(path, options, callback) - асинхронно читає вміст файлу вказаним шляхом. Повертає вміст у вигляді буфера або рядка, залежно від переданих опцій.

- fs.readFileSync(path, options) - синхронно читає вміст файлу вказаним шляхом. Повертає вміст у вигляді буфера або рядка, залежно від переданих опцій.

- fs.writeFile(file, data, options, callback) - асинхронно записує дані у файл. Якщо файл існує, його вміст буде замінено. Якщо файл не існує, він буде створений.

- fs.writeFileSync(file, data, options) - синхронно записує дані у файл. Якщо файл існує, його вміст буде замінено. Якщо файл не існує, він буде створений.

- fs.appendFile(file, data, options, callback) - асинхронно додає дані до кінця файла. Якщо файл не існує, він буде створений.

- fs.appendFileSync(file, data, options) - синхронно додає дані до кінця файлу. Якщо файл не існує, він буде створений.

- fs.unlink(path, callback) - асинхронно видаляє файл за вказаним шляхом.

- fs.unlinkSync(path) - синхронно видаляє файл за вказаним шляхом.

- fs.existsSync(path) - перевіряє, чи існує файл вказаним шляхом. Повертає true, якщо файл існує, і false інакше.

- fs.mkdir(path, options, callback) - асинхронно створює нову директорію зазначеним шляхом.

- fs.mkdirSync(path, options) - синхронно створює нову директорію вказаним шляхом.

- fs.readdir(path, options, callback) - асинхронно повертає список файлів та директорій у зазначеній директорії.

- fs.readdirSync(path, options) - синхронно повертає список файлів та директорій у зазначеній директорії.

- fs.rmdir(path, callback) - асинхронно видаляє порожню директорію зазначеним шляхом.

- fs.rmdirSync(path) - синхронно видаляє порожню директорію зазначеним шляхом.
```
40. Як відбувається налагодження тестів у Cypress?
```
Налагодження тестів у Cypress відбувається за допомогою інструментів розробника браузера, таких як Chrome DevTools або Firefox Developer Tools. 
Ось декілька способів, які можуть допомогти при налагодженні тестів у Cypress:

1. Використання методу debug() у ланцюжку команд Cypress. Це дозволяє вставити точку зупинки в тест і відкрити інструменти розробника на цій точці.

2. Використання методу pause() у ланцюжку команд Cypress. Це дозволяє призупинити виконання тесту та відкрити інструменти розробника для налагодження.

3. Використання cy.log() для виведення налагоджувальних повідомлень у консоль Cypress.

4. Використання інструментів розробника браузера для аналізу елементів на сторінці, логів мережевих запитів та інших аспектів програми.

5. Використання debugger у коді тесту. Це дозволяє вставити точку зупинки та відкрити інструменти розробника у браузері для налагодження.

```
41. Які інструменти використовуєте для профілювання продуктивності?
```
Для профілювання продуктивності додатків та веб-сайтів існує безліч інструментів, деякі з яких наведені нижче:

1. Chrome DevTools: це інструмент, вбудований у браузер Google Chrome, який дозволяє аналізувати продуктивність веб-сторінок та програм, включаючи відстеження часу завантаження ресурсів, подій та запитів.

2. Lighthouse: це автоматизований інструмент для аналізу продуктивності та якості веб-сторінок, доступний як розширення для Chrome та Firefox, а також як Node.js-модуль. Він надає детальну інформацію про продуктивність, доступність, практики SEO та інші аспекти веб-сторінки.

3. WebPagetest: це безкоштовний онлайн-сервіс, який дозволяє тестувати продуктивність веб-сторінок із різних місць та на різних пристроях. Він надає докладну інформацію про завантаження ресурсів, час відгуку сервера та інші аспекти продуктивності.

4. JMeter: це інструмент для тестування продуктивності, який можна використовувати для перевірки продуктивності веб-додатків, баз даних та інших систем. Він дозволяє створювати та запускати тести з різними параметрами, а також аналізувати результати тестування.

5. New Relic: це інструмент моніторингу продуктивності, який надає безліч функцій, включаючи відстеження продуктивності серверів, веб-додатків та мобільних програм. Він може використовуватися для аналізу продуктивності, виявлення помилок та оптимізації додатків.

6. Apache Bench: інструмент командного рядка для тестування продуктивності веб-серверів. Він може використовуватися для створення навантаження на сервер та аналізу часу відгуку та пропускної спроможності сервера.

7. Siege: це інструмент для тестування продуктивності, який може використовуватися для створення навантаження на веб-сервери та аналізу часу відгуку та пропускної спроможності сервера.

8. GTmetrix: це онлайн-сервіс для аналізу продуктивності веб-сторінок, який надає інформацію про завантаження ресурсів, час відгуку сервера та інші аспекти продуктивності.

9. YSlow: це розширення для Chrome, Firefox та Safari, яке дозволяє аналізувати продуктивність веб-сторінок

Тут перераховані манульні інструменти.
Також в залежності від контексту питання в цей список можна включити ряд фреймворків для автоматизації перфоманс тестування і ряд інструментів для моніторингу.
```
42. Які проблеми швидкодії можуть виникнути під час використання Cypress?
```
Незважаючи на те, що Cypress є досить швидким інструментом для автоматизації тестування, при використанні можуть виникати такі проблеми з продуктивністю:

1. Неефективне використання селекторів: Якщо селектори в тестах є неефективними, Cypress може витрачати багато часу на пошук елементів на сторінці.

2. Довгі часові інтервали: Якщо в тестах використовуються довгі часові інтервали, виконання тестів може займати більше часу, ніж необхідно.

3. Неефективне використання методів Cypress: Якщо методи Cypress використовуються неефективно, це може сповільнити виконання тестів.

4. Повільна взаємодія з веб-браузером: Cypress виконує тести всередині реального веб-браузера, що може спричинити затримки під час взаємодії з елементами на сторінці.

5. Тривале очікування елементів: Cypress автоматично чекає, доки елемент стане доступним на сторінці, перш ніж продовжити виконання тесту. 
Однак це може призвести до затримок, особливо під час роботи з повільними елементами або в умовах низької швидкості мережі.

6. Неефективне використання ресурсів: Cypress може споживати велику кількість пам'яті та процесорного часу під час запуску великої кількості тестів або під час роботи з важкими сторінками.

7. Проблеми з конфігурацією та налаштуваннями: Неправильна конфігурація та налаштування Cypress можуть призвести до уповільнення виконання тестів та інших проблем продуктивності.

```
43. Як ви вибираєте тест кейси для автоматизації?
44. Як ви обробляєте помилки у тестах Cypress?
```
Обробка помилок у тестах Cypress є важливою частиною процесу тестування, щоб розуміти, що відбувається з тестом, коли він не проходить.

Є кілька способів обробки помилок у тестах Cypress:

1. Використання команди cy.on('uncaught:exception', ...) для перехоплення необроблених винятків та виконання відповідних дій (наприклад, логування помилки, повторний запуск тесту тощо).

2. Використання методу .should() для перевірки наявності елемента на сторінці. Якщо елемент не знайдено, це може спричинити помилку, яку можна обробити.

3. Використання блоку try-catch для обробки синхронних помилок.

4. Використання конструкції async/await для обробки асинхронних помилок.

5. Використання налагоджувальної інформації (логів та скріншотів), щоб зрозуміти причини помилок та усунути їх.

6. Використання інструментів для генерації звітів про проходження тестів, які дозволяють швидко визначити помилки та взаємодіяти з ними.

Важливо пам'ятати, що обробка помилок у тестах Cypress повинна бути частиною загального підходу до тестування, який включає розуміння та аналіз проблем, а також їх усунення разом з командою розробки.
```
45. Який процес оновлення тестів відбувається під час оновлення додатку?
```
Після оновлення додатку може знадобитися оновлення тестових сценаріїв для врахування нових функцій або змін інтерфейсу користувача. 
Процес оновлення тестів може включати такі кроки:

1. Аналіз змін: після оновлення програми необхідно проаналізувати, які зміни впливають на функціональність та інтерфейс користувача. 
Це може включати перевірку нових елементів на сторінці, зміна функціональності існуючих елементів, зміна URL-адрес і т.д.

2. Оновлення існуючих тестів: після аналізу змін необхідно оновити існуючі тестові сценарії, щоб вони відображали нові функції та зміни інтерфейсу користувача. 
Зазвичай це включає зміну селекторів елементів, оновлення введених даних і перевірок.

3. Написання нових тестів: при оновленні програми можуть додаватися нові функції та сторінки, які раніше не були протестовані. 
Необхідно написати нові тестові сценарії для перевірки нових функцій та сторінок.

4. Перевірка стабільності: після оновлення тестових сценаріїв необхідно перевірити їхню стабільність та працездатність. 
Важливо переконатися, що тести проходять успішно на різних оточеннях та пристроях.

5. Перегляд архітектури тестів: під час оновлення програми може знадобитися перегляд архітектури тестів. 
Наприклад, якщо були внесені великі зміни в додатку, може знадобитися перебудувати тести так, щоб вони були більш стійкими до майбутніх змін.

6. Повторне виконання тестів: після оновлення тестів необхідно повторно виконати їх, щоб переконатися, що вони ще працюють правильно.

7. Інтеграція в CI/CD: після оновлення тестів та перевірки їхньої стабільності вони повинні бути інтегровані в процес CI/CD, щоб автоматично запускатися при кожному оновленні програми.
```
46. Які інструменти ви використовували для автоматизованого тестування?
47. Як ви підтримуєте тестову базу даних?
48. Як ви визначаєте цілі та вимоги для автоматизації тестування?
49. Який процес код-рев'ю у вашій команді?
50. Як ви оновлюєте свої знання у тестуванні та автоматизації?
